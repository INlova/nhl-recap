import Rx from 'rx';
import _ from 'lodash';
import chai from 'chai';

import periodClock from '../app/js/period-clock';

const onNext = Rx.ReactiveTest.onNext;
const onCompleted = Rx.ReactiveTest.onCompleted;
const scheduleTime = 200;
const scheduleInterval = 1;

const assert = chai.assert;

// Use short period times to speed up the tests
const periodLengthInMinutes = 3;
const period = 1;

describe('periodClock', () => {

  const firstElement = (minute) => onNext(scheduleTime + scheduleInterval, { period, minute, second: 0 });
  const completedElement = (elementIndex) => onCompleted(scheduleTime + (elementIndex + 1) * scheduleInterval);

  it('should run full period if no end time is given', () => {
    const clockObserver = scheduleClock(periodLengthInMinutes, null, (clock$) => clock$.takeLast(1));

    const elementCount = 722;
    const lastTimeElement = onNext(scheduleTime + elementCount * scheduleInterval, { period, minute: 0, second: 0, tenthOfASecond: 0 });
    const expected = [lastTimeElement];

    // Ignore last completed message because it is generated by 'takeLast' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

  it('should stop at given end time', () => {
    const endTime = { minute: 2, second: 53 };
    const clockObserver = scheduleClock(periodLengthInMinutes, endTime, (clock$) => clock$);

    const secondElements = _.range(59, endTime.second - 1, -1).map((second, index) =>
      onNext(scheduleTime + (index + 2) * scheduleInterval, { period, minute: 2, second })
    );
    const elementCount = secondElements.length + 1;
    const expected = [firstElement(periodLengthInMinutes)].concat(secondElements, completedElement(elementCount));

    assert.deepEqual(clockObserver.messages, expected);
  });

  it('should advance by second for all minutes of a period but the last one', () => {
    const clockObserver = scheduleClock(periodLengthInMinutes, null, (clock$) => clock$.take((periodLengthInMinutes - 1) * 60 + 1));

    const minutes = _.range(periodLengthInMinutes - 1, 0, -1);
    const seconds = _.range(59, -1, -1);
    const secondElements = _.flatten(minutes.map((minute, minuteIndex) =>
      seconds.map((second, secondIndex) => {
        const scheduleDelay = (minuteIndex * seconds.length) + secondIndex + 2;
        return onNext(scheduleTime + scheduleDelay * scheduleInterval, { period, minute, second });
      })
    ));
    const expected = [firstElement(periodLengthInMinutes)].concat(secondElements);

    // Ignore last completed message because it is generated by 'take' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

  it('should advance by tenth of a second for the last minute of a period', () => {
    // Take only the first second to speed up and simplify the test
    const clockObserver = scheduleClock(1, null, (clock$) => clock$.take(11));

    const tenthOfASecondElements = _.range(9, -1, -1).map((tenthOfASecond, index) =>
      onNext(scheduleTime + (index + 2) * scheduleInterval, { period, minute: 0, second: 59, tenthOfASecond })
    );
    const expected = [firstElement(1)].concat(tenthOfASecondElements);

    // Ignore last completed message because it is generated by 'take' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

});

function scheduleClock(periodLength, endTime, transformFn) {
  const scheduler = new Rx.TestScheduler();
  const clock$ = periodClock(period, periodLength, endTime, scheduleInterval, scheduler);
  return scheduler.startScheduler(() => transformFn(clock$));
}
