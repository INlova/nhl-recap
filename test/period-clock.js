import Rx from 'rx';
import _ from 'lodash';
import chai from 'chai';

import periodClock from '../app/js/period-clock';

const onNext = Rx.ReactiveTest.onNext;
const onCompleted = Rx.ReactiveTest.onCompleted;
const scheduleTime = 200;
const scheduleInterval = 1;

const assert = chai.assert;

// Use short period times to speed up the tests
const periodLengthInMinutes = 3;

const clockAdvanceStep = 3;

describe('periodClock', () => {

  it('should run full period if no end time is given', () => {
    const clockObserver = scheduleClock(1, periodLengthInMinutes, null, [], (clock$) => clock$.takeLast(1));

    const elementCount = 62;
    const lastTimeElement = onNext(scheduleTime + elementCount * scheduleInterval,
      { period: 1, minute: 0, second: 2 });
    const expected = [lastTimeElement];

    // Ignore last completed message because it is generated by 'takeLast' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

  it('should stop at given end time', () => {
    const period = 1;
    const endTime = { minute: 2, second: 53 };
    const clockObserver = scheduleClock(period, periodLengthInMinutes, endTime, []);

    const secondElements = _.range(59, endTime.second - 1, -clockAdvanceStep).map((second, index) =>
      onNext(scheduleTime + (index + 2) * scheduleInterval, { period, minute: 2, second })
    );
    const elementCount = secondElements.length + 1;
    const expected = [firstElement(period, periodLengthInMinutes)].concat(secondElements, completedElement(elementCount));

    assert.deepEqual(clockObserver.messages, expected);
  });

  it('should advance by three seconds for all minutes of a period but the last one', () => {
    const period = 1;
    const clockElementCount = (((periodLengthInMinutes - 1) * 60) / clockAdvanceStep) + 1;
    const clockObserver = scheduleClock(period, periodLengthInMinutes, null, [],
      (clock$) => clock$.take(clockElementCount));

    const minutes = _.range(periodLengthInMinutes - 1, 0, -1);
    const seconds = _.range(59, -1, -clockAdvanceStep);
    const secondElements = _.flatten(minutes.map((minute, minuteIndex) =>
      seconds.map((second, secondIndex) => {
        const scheduleDelay = (minuteIndex * seconds.length) + secondIndex + 2;
        return onNext(scheduleTime + scheduleDelay * scheduleInterval, { period, minute, second });
      })
    ));
    const expected = [firstElement(period, periodLengthInMinutes)].concat(secondElements);

    // Ignore last completed message because it is generated by 'take' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

  it('should advance by three seconds for the last minute of any period but the 3rd one', () => {
    [1, 2, 'OT'].forEach(period => {
      // Use only one minute period length to speed up and simplify the test
      const periodLength = 1;
      const clockObserver = scheduleClock(period, periodLength, null, []);

      const secondElements = _.range(59, -1, -clockAdvanceStep).map((second, index) =>
        onNext(scheduleTime + (index + 2) * scheduleInterval, { period, minute: 0, second })
      );
      const expected = [firstElement(period, periodLength)].concat(secondElements);

      // Ignore last completed message because it is generated by 'take' in the scheduler function
      assert.deepEqual(_.dropRight(clockObserver.messages), expected);
    });
  });

  it('should advance by three tenths of a second for the last minute of the 3rd period', () => {
    const period = 3;
    const periodLength = 1;
    // Take only the first second to speed up and simplify the test
    const clockObserver = scheduleClock(period, periodLength, null, [], (clock$) => clock$.take(5));

    const tenthOfASecondElements = _.range(9, -1, -clockAdvanceStep).map((tenthOfASecond, index) =>
      onNext(scheduleTime + (index + 2) * scheduleInterval, { period, minute: 0, second: 59, tenthOfASecond })
    );
    const expected = [firstElement(period, periodLength)].concat(tenthOfASecondElements);

    // Ignore last completed message because it is generated by 'take' in the scheduler function
    assert.deepEqual(_.dropRight(clockObserver.messages), expected);
  });

  it('should pause the clock by multiplying clock time elements when a goal was scored since last clock time', () => {
    const assertLastElement = (goalScoringTimes, expectedGoalScoreCount, description) => {
      const period = 1;
      const periodLength = 20;
      const elementMultiplier = 50;

      const clockObserver = scheduleClock(period, periodLength, null, goalScoringTimes, (clock$) => clock$.takeLast(1));
      const elementCount = 402 + (expectedGoalScoreCount * (elementMultiplier - 1));
      const lastTimeElement = onNext(scheduleTime + elementCount * scheduleInterval,
        { period: 1, minute: 0, second: 2 });
      const expected = [lastTimeElement];

      // Ignore last completed message because it is generated by 'takeLast' in the scheduler function
      assert.deepEqual(_.dropRight(clockObserver.messages), expected, description);
    };

    // Assert that last element is as expected without goal scoring times
    assertLastElement([], 0, 'last element without goal scoring times');

    // Assert that last element is as expected with goal scoring times
    const goalScoringTimes = [
      { period: 1, min: 1, sec: 1 },
      { period: 1, min: 2, sec: 2 },
      { period: 2, min: 1, sec: 1 }
    ];
    assertLastElement(goalScoringTimes, 2, 'last element with goal scoring times');
  });

});

function scheduleClock(period, periodLength, endTime, goalScoringTimes, transformFn = _.identity) {
  const scheduler = new Rx.TestScheduler();
  const clock$ = periodClock(period, periodLength, endTime, goalScoringTimes, scheduleInterval, scheduler);
  return scheduler.startScheduler(() => transformFn(clock$));
}

function firstElement(period, minute) {
  return onNext(scheduleTime + scheduleInterval, { period, minute, second: 0 });
}

function completedElement(elementIndex) {
  return onCompleted(scheduleTime + (elementIndex + 1) * scheduleInterval);
}
